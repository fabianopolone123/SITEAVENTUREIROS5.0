{% load static %}
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Cadastro de Aventureiros</title>
  <link rel="stylesheet" href="{% static 'css/cadastro.css' %}">
</head>
<body>
  <div class="cadastro-page">
    <div class="floating-glow"></div>
    <div class="cadastro-card">
      <div class="cadastro-head">
        <div class="logo-shell small">
          <div class="logo-glow">
            <img src="{% static 'images/logo.png' %}" alt="Logo do Clube de Aventureiros">
          </div>
        </div>
        <p class="tagline">ESPAÇO DO CLUBE</p>
        <h1>Cadastro de Aventureiros</h1>
        <p class="subtitle">Fluxo guiado para registrar responsável, aventureiros, fichas médicas e autorizações.</p>
      </div>

      {% if current_step == 'tipo' %}
        <div class="wizard-progress compact">
          <div class="step is-current">Escolha do cadastro</div>
        </div>
      {% else %}
        <div class="summary-stack summary-top">
          <div class="summary-states">
            <span>Responsável: <span class="status-badge">{{ status.responsible }}</span></span>
            {% for adv in status.adventurers %}
              <span>{{ adv.name }} → Dados {{ adv.data }}, Ficha {{ adv.medical }}, Termo {{ adv.term }}</span>
            {% empty %}
              <span class="info-pill">Nenhum aventureiro cadastrado ainda</span>
            {% endfor %}
          </div>
        </div>

        <div class="wizard-progress">
          {% for step_id, step_label in steps %}
            {% if forloop.counter0 < current_index %}
              <div class="step is-complete">{{ step_label }}</div>
            {% elif forloop.counter0 == current_index %}
              <div class="step is-current">{{ step_label }}</div>
            {% else %}
              <div class="step">{{ step_label }}</div>
            {% endif %}
          {% endfor %}
        </div>

        <div class="summary-stack">
          <h3>Pendências detectadas</h3>
          <ul>
            {% if pendings %}
              {% for pending in pendings %}
                <li><strong>{{ pending.section }}:</strong> {{ pending.items|join:', ' }}</li>
              {% endfor %}
            {% else %}
              <li><em>Nenhuma pendência no momento.</em></li>
            {% endif %}
          </ul>
        </div>
      {% endif %}

      <div class="stage-content">
        {% block stage_content %}{% endblock %}
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const labelFor = (input) => {
        if (!input) return null;
        return document.querySelector(`[for="${input.id}"]`);
      };

      const setAutofillLabel = (input, active) => {
        const label = labelFor(input);
        if (!label) return;
        if (!label.dataset.originalText) {
          label.dataset.originalText = label.textContent.trim();
        }
        label.textContent = active
          ? `${label.dataset.originalText} (Preenchido automaticamente)`
          : label.dataset.originalText;
      };

      const signatureCanvases = document.querySelectorAll('[data-signature-target]');
      signatureCanvases.forEach((canvas) => {
        const target = document.getElementById(canvas.dataset.signatureTarget);
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        ctx.strokeStyle = '#202020';
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        let drawing = false;

        const pointerDown = (event) => {
          drawing = true;
          ctx.beginPath();
          ctx.moveTo(event.offsetX, event.offsetY);
        };
        const pointerMove = (event) => {
          if (!drawing) return;
          ctx.lineTo(event.offsetX, event.offsetY);
          ctx.stroke();
        };
        const pointerUp = () => {
          if (!drawing) return;
          drawing = false;
          if (target) {
            target.value = canvas.toDataURL();
          }
        };

        canvas.addEventListener('pointerdown', pointerDown);
        canvas.addEventListener('pointermove', pointerMove);
        canvas.addEventListener('pointerup', pointerUp);
        canvas.addEventListener('pointerout', pointerUp);

        const parentElement = canvas.parentElement;
        const clearBtn = parentElement ? parentElement.querySelector('[data-clear-target]') : null;
        if (clearBtn) {
          clearBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (target) {
              target.value = '';
            }
          });
        }
      });

      const photoInput = document.querySelector('[data-photo-input]');
      const photoPreview = document.querySelector('[data-photo-preview]');
      const photoTarget = document.querySelector('[data-photo-target]');
      if (photoInput && photoTarget) {
        photoInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) {
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            photoTarget.value = reader.result;
            if (photoPreview) {
              photoPreview.src = reader.result;
            }
          };
          reader.readAsDataURL(file);
        });
      }

      const useResponsible = document.querySelector('[data-use-responsible]');
      const responsibleAddress = {
        address_line: "{{ responsible.address_line|default:''|escapejs }}",
        neighborhood: "{{ responsible.neighborhood|default:''|escapejs }}",
        city: "{{ responsible.city|default:''|escapejs }}",
        state: "{{ responsible.state|default:''|escapejs }}",
        cep: "{{ responsible.cep|default:''|escapejs }}",
      };

      if (useResponsible) {
        const toggleAddress = () => {
          const checked = useResponsible.checked;
          ['address_line', 'neighborhood', 'city', 'state', 'cep'].forEach((field) => {
            const input = document.getElementById('id_' + field);
            if (!input) return;
            if (checked) {
              input.value = responsibleAddress[field] || '';
              input.readOnly = true;
              setAutofillLabel(input, true);
            } else {
              if (input.dataset.autofill === 'true') {
                input.value = '';
              }
              input.readOnly = false;
              setAutofillLabel(input, false);
            }
          });
        };
        useResponsible.addEventListener('change', toggleAddress);
        toggleAddress();
      }

      const legalType = document.getElementById('id_legal_type');
      const legalFields = [
        { id: 'id_legal_name', key: 'name' },
        { id: 'id_legal_cpf', key: 'cpf' },
        { id: 'id_legal_email', key: 'email' },
        { id: 'id_legal_phone', key: 'phone' },
        { id: 'id_legal_relationship', key: 'relationship' },
      ];

      const parentSources = {
        pai: {
          name: '#id_father_name',
          cpf: '#id_father_cpf',
          email: '#id_father_email',
          phone: '#id_father_phone',
          relationship: 'Pai',
        },
        mae: {
          name: '#id_mother_name',
          cpf: '#id_mother_cpf',
          email: '#id_mother_email',
          phone: '#id_mother_phone',
          relationship: 'Mãe',
        },
      };

      const getSourceValue = (type, key) => {
        const selectors = parentSources[type];
        if (!selectors) return '';
        const reference = selectors[key];
        if (!reference) return '';
        if (reference.startsWith('#')) {
          const element = document.querySelector(reference);
          return element ? element.value : '';
        }
        return reference;
      };

      const tryAutofillField = (input, value) => {
        if (!input || input.dataset.manual === 'true') {
          return;
        }
        if (value) {
          input.dataset.autofill = 'true';
          input.value = value;
          setAutofillLabel(input, true);
        } else if (input.dataset.autofill === 'true') {
          input.dataset.autofill = 'false';
          input.value = '';
          setAutofillLabel(input, false);
        }
      };

      const updateLegalFields = () => {
        if (!legalType) return;
        const type = legalType.value;
        const hasParent = Boolean(parentSources[type]);
        legalFields.forEach(({ id, key }) => {
          const input = document.getElementById(id);
          if (!input) return;
          if (!hasParent) {
            if (input.dataset.autofill === 'true') {
              input.dataset.autofill = 'false';
            }
            setAutofillLabel(input, false);
            return;
          }
          input.dataset.manual = 'false';
          const value = getSourceValue(type, key);
          tryAutofillField(input, value);
        });
      };

      legalFields.forEach(({ id }) => {
        const input = document.getElementById(id);
        if (!input) return;
        input.addEventListener('input', () => {
          input.dataset.manual = 'true';
          setAutofillLabel(input, false);
        });
      });

      if (legalType) {
        legalType.addEventListener('change', updateLegalFields);
        updateLegalFields();
      }
    });
  </script>
</body>
</html>
